/**
 * Generate the Python code for the notebook
 *
 * Copyright 2022 CS GROUP - France, http://www.c-s.fr
 * All rights reserved
 */

import { geojsonToWKT } from '@terraformer/wkt';

import { IFormInput } from './types';
import { formatDate } from './utils';

const formatCode = (
  {
    startDate,
    endDate,
    productType,
    geometry,
    additionnalParameters,
    provider,
    ...extraParams
  }: IFormInput,
  replaceCode: boolean
) => {
  const start = startDate ? formatDate(startDate) : undefined;
  const end = endDate ? formatDate(endDate) : undefined;
  const tab = ' '.repeat(4);
  const geometryIsOk = geometry?.type && geometry?.coordinates;

  const replacedCellIntro =
    '# Code generated by eodag-labextension, will be automatically replaced if a new search is performed';
  const standardMessage = `from eodag import EODataAccessGateway, setup_logging

setup_logging(1)  # 0: nothing, 1: only progress bars, 2: INFO, 3: DEBUG

dag = EODataAccessGateway()`;

  let code = replaceCode
    ? `${replacedCellIntro}
${standardMessage}`
    : `${standardMessage}`;

  if (geometryIsOk) {
    code += `
geometry = "${geojsonToWKT(geometry)}"`;
  }
  code += `
search_results = dag.search(`;
  if (provider) {
    code += `
    provider="${provider}",`;
  }
  code += `
    productType="${productType}",`;
  if (geometryIsOk) {
    code += `
    geom=geometry,`;
  }
  if (start) {
    code += `
    start="${start}",`;
  }
  if (end) {
    code += `
    end="${end}",`;
  }
  const filteredParameters = additionnalParameters.filter(
    ({ name, value }) => name && value && name !== '' && value !== ''
  )

  const extraParamEntries = Object.entries(extraParams).filter(([_, value]) => value !== undefined);

  if (filteredParameters.length > 0 || extraParamEntries.length > 0) {
    code += '\n' + tab + '**{\n';

    // Map additionnalParameters
    code += filteredParameters.map(({ name, value }) => {
      const processedValue = Array.isArray(value)
        ? `[${value.map((item: any) => (typeof item === 'string' ? `"${item.trim()}"` : item)).join(', ')}]`
        : typeof value === 'string'
          ? `"${value.trim()}"`
          : value;
      return `${tab + tab}"${name}": ${processedValue},`;
    }).join('\n');

    // Map extra parameters dynamically
    if (extraParamEntries.length > 0) {
      if (filteredParameters.length > 0) code += '\n'; // Separate sections
      code += extraParamEntries.map(([key, value]) => {
        const processedValue = Array.isArray(value)
          ? `[${value.map((item: any) => (typeof item === 'string' ? `"${item.trim()}"` : item)).join(', ')}]`
          : typeof value === 'string'
            ? `"${value.trim()}"`
            : value;
        return `${tab + tab}"${key}": ${processedValue},`;
      }).join('\n');
    }

    code += '\n' + `${tab}}`; // Close dictionary
  }
  code += '\n)';

  return code;
};

export default formatCode;
